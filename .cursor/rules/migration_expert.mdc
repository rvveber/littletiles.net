---
description: Follow exactly for any tasks that involve schema updates.
globs: 
alwaysApply: false
---
# Directus Migrations Best Practice für LLMs

**WICHTIG:**  
Nach jeder Änderung an Migrationen (egal ob neu, angepasst oder gelöscht) ist der automatisierte Testbefehl auszuführen und die Backend-Logs sind auf Fehler zu prüfen.  
Erst nach erfolgreichem Testlauf gilt die Migration als abgeschlossen.

## Über diese Regel

Diese MDC-Regel ist ein lebendes Dokument, das kontinuierlich durch Erfahrung und neue Erkenntnisse verbessert werden soll. 
Es befindet sich in .cursor/rules/migration_expert.mdc.

Als KI-Assistant:
- Passe ich die Regel basierend auf gesammelten Erfahrungen an
- Ergänze Best Practices, die sich in der Praxis bewährt haben
- Dokumentiere Lösungen für aufgetretene Probleme
- Optimiere Vorgehensweisen basierend auf Feedback
- Verfeinere die Regel, wenn neue Muster oder Herausforderungen erkannt werden

Die Regel spiegelt damit den aktuellen Stand meines Wissens und meiner Erfahrung wider und entwickelt sich stetig weiter.

## LLM-spezifische Richtlinien

1. **Sprechende, thematische Dateinamen**
   - Verwende das Format: `YYYYMMDD[A-Z]-operation_scope.js`
   - Der Dateiname beschreibt präzise die Operation und den Scope (z.B. create, add, update, remove, drop, rename, ...).
   - Beispiele:
     ```
     20250611A-create_structure_posts.js
     20250611B-add_files_junction_to_structure_posts.js
     20250611C-create_moderator_role_and_permissions.js
     20250611D-add_minecraft_user_ref_to_directus_users.js
     ```
   - **Operationen**: create, add, update, remove, drop, rename, ...
   - **Scope**: Was wird gemacht? (z.B. Feld, Relation, Rolle, Policy, etc.)

2. **Migrationen thematisch und atomar aufteilen**
   - Eine Migration = Ein logischer, abgeschlossener Schritt (z.B. neue Tabelle, neue Rolle, neue Relation, größere Feldänderung).
   - Vermeide zu große "Sammel-Migrationen" oder zu kleine "Mini-Migrationen".
   - Beispiele:
     - `create_structure_posts.js` (legt Tabelle + Felder + Metadaten an)
     - `add_files_junction_to_structure_posts.js` (legt Junction-Tabelle + Felder + Metadaten an)
     - `add_minecraft_user_ref_to_directus_users.js` (fügt Referenzfeld + Metadaten hinzu)
     - `create_moderator_role_and_permissions.js` (legt Rolle, Policy, Berechtigungen an)

3. **Dokumentation und Struktur**
   - Jede Migration erhält einen JSDoc-Kommentar mit:
     - **@description** (Was macht die Migration?)
     - **@affects** (Welche Tabellen/Collections/Metadaten werden verändert?)
     - **@operation** (create, add, update, remove, ...)
   - Strukturierte Code-Blöcke:
     ```javascript
     export async function up(knex) {
         // 1. KONSTANTEN
         // 2. VALIDIERUNG
         // 3. SCHEMA
         // 4. METADATEN
         // 5. BERECHTIGUNGEN
     }
     export async function down(knex) {
         // Reihenfolge umkehren!
     }
     ```

4. **Fehlerbehandlung, Validierung, Rollback**
   - try/catch, Validierung, Down-Migrationen, atomare Blöcke wie gehabt.

5. **Automatisiertes Testen**
   - Migrationen werden beim Backend-Start automatisch angewendet.
   - Testbefehl:
     ```bash
     docker compose down -v && docker compose up -d && sleep 6 && docker compose logs backend
     ```
   - Überprüfe die Logs auf Fehler oder Hinweise auf fehlgeschlagene Migrationen.

## Automatische Validierung, Fehlerbehebung, Selbstoptimierung, Aufräumen
- Siehe bisherige Abschnitte (bleiben bestehen, werden aber auf sprechende Migrationen angewendet).

## Fehlerbehebung

1. **Häufige Fehler und Lösungen**
   ```javascript
   // Problem: Tabelle existiert bereits
   if (error.code === '42P07') {
       // Lösung: Drop und Recreate
       await knex.schema.dropTableIfExists('table_name');
       await knex.schema.createTable('table_name', ...);
   }

   // Problem: Fremdschlüssel-Constraint verletzt
   if (error.code === '23503') {
       // Lösung: Cascade Delete
       await knex.schema.alterTable('table_name', table => {
           table.dropForeign(['column_name']);
           table.foreign('column_name').references('id').inTable('other_table').onDelete('CASCADE');
       });
   }
   ```

2. **Rollback-Strategien**
   ```javascript
   export async function down(knex) {
       try {
           // 1. Temporäre Sicherung
           await knex.schema.renameTable('table_name', 'table_name_backup');
           
           // 2. Rollback durchführen
           await knex.schema.dropTable('table_name');
           
           // 3. Bei Erfolg: Backup löschen
           await knex.schema.dropTable('table_name_backup');
       } catch (error) {
           // 4. Bei Fehler: Backup wiederherstellen
           await knex.schema.renameTable('table_name_backup', 'table_name');
           throw error;
       }
   }
   ```

## Iterative Selbstoptimierung

1. **Kontinuierliche Verbesserung**
   ```mermaid
   graph TD
       A[Ausführen] --> B[Prüfen]
       B --> C[Anpassen]
       C --> D[Validieren]
       D --> A
   ```

2. **Erfolgskriterien**
   - Alle Tabellen entsprechen dem Schema
   - Alle Beziehungen sind korrekt
   - Keine Fehler in den Logs
   - Metadaten sind vollständig

3. **Automatische Anpassung**
   - Lerne aus Fehlern
   - Optimiere Strategien
   - Verbessere Dokumentation
   - Aktualisiere Best Practices

## Aufräumen

Als LLM achte ich besonders auf:

1. **Dateiorganisation**
   - Lösche alte/doppelte Migrations-Dateien
   - Überprüfe Namenskonventionen
   - Stelle sicher, dass keine temporären Dateien bleiben


2. **Metadaten-Bereinigung**
   - Entferne nicht mehr benötigte Collection-Einträge
   - Aktualisiere Berechtigungen
   - Bereinige Feldkonfigurationen 

## Automatisiertes Testen der Migrationen

**Migrationen werden automatisch beim Start des Backends angewendet.**

**Testbefehl für die Migrationen:**

```bash
docker compose down -v && docker compose up -d && sleep 6 && docker compose logs backend
```

- Dieser Befehl setzt die Umgebung zurück, startet alle Container neu und zeigt die Backend-Logs an.
- Überprüfe die Logs auf Fehler oder Hinweise auf fehlgeschlagene Migrationen. 

6. **Datenbank-Validierung mit MCP**
   - Nutze das MCP-Tool, um die aktuelle Datenbankstruktur und Metadaten direkt abzufragen (z.B. Spalten, Feldtypen, Constraints, Metadaten in directus_fields/collections).
   - Dies hilft, Migrationen gezielt und sicher zu planen und zu validieren.

7. **Initiale Migrationen bei neuen Projekten**
   - Bei frischen Projekten ohne Migrationsbedarf können Migrationen zusammengefasst werden.
   - Felder und Strukturen werden direkt im gewünschten Endzustand angelegt (z.B. description statt content, Status-Feld direkt mit allen gewünschten Werten, archiviert-Checkbox direkt anlegen).
   - Reduziere die Anzahl der Migrationen auf das notwendige Minimum für den initialen Stand. 

8. **Eindeutige Migrations-Dateinamen**
   - Jeder Migrations-Dateiname muss eindeutig sein (Zeitstempel + Suffix, z.B. 20250611A, 20250611B, ...).
   - Es dürfen keine doppelten Keys existieren, da Directus sonst die Migrationen nicht ausführen kann. 

9. **Autonomie für den Assistenten**
   - Der Assistent darf bei offensichtlichen Redundanzen, Fehlern oder Optimierungsmöglichkeiten eigenständig und ohne Rückfrage Migrationen löschen, zusammenfassen oder aufräumen.
   - Ziel ist ein stets optimaler, wartbarer und fehlerfreier Migrationsstand. 

10. **Comments and Documentation in English**
    - All comments in code, including JSDoc, must always be written in English.
    - The assistant will always optimize and generate new migrations with English comments and documentation. 